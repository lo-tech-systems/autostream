#!/usr/bin/python3
"""autostream_wifi_watcher.py

Copyright (c) 2025 Lo-tech Systems Limited. All rights reserved.

This module should be run continuously as root. It monitors (and logs) the network
connection status of the device.

== Access Point Mode ==

If the WiFi is unconfigured or remains disconnected for 1 minute after boot, it is put into
AP mode with a captive portal that enables the user to easily connect the Pi to the WiFi.
This AP mode will remain active for up to 15 minutes. After that time, to re-enter AP mode,
the user would need to power-cycle the device. As an exception to this, note that if the
user provided WiFi connection details didn't work (e.g., wrong password), the AP mode will
re-activated and the timer reset for up to another 15 minutes.

If a wired ethernet connection is up, the AP mode is supressed.

If there is a WiFi connection configured, but the wired connection is down, when the script
closes AP mode after the allowed 15 minutes it will try to connect to that connection
periodically. If there is no connection still after 24 hours, the device will be rebooted
and the process will repeat.

== Connection Reliability ==

If the WiFi is configured and the wired connection is down, the script monitors the network
health by monitoring the kernel's view of the default gateway. If this goes offline for more
than 5 minutes, the script trys to reconnect to the network periodically.

If the gateway remains unreachable for more than 30 minutes, the script will reboot the device.
Whilst this seems aggressive, the WiFi chipset in the Pi-Zero range is not great in terms
of long periods of uptime so this is a defensive strategy. Music can't play if the device
isn't on the network anyway.

Note that this script always serves the setup page. The associated NGINX configuration
controls which web server (this or autostream_webui.py) services requests via the presence
(or not) of /tmp/apmode.
"""

import os
import time
import threading
import logging
import sys
import html
import json
from typing import Optional
from flask import Flask, request, jsonify, redirect, url_for, make_response
from dataclasses import dataclass

from autostream_sysutils import run_cmd, prime_gateway, reboot_system, get_system_hostname

from autostream_rpi import check_cpu

from autostream_webui_assets import STYLE_CSS, BANNER_HTML

# File locations
LOG_FILE = "/var/log/autostream/wifi_setup.log"
CONFIGURED_SSID = "/opt/autostream/ssid"
AP_MODE_FLAG_PATH = "/tmp/apmode"

# Timers (all in seconds)
NETWORK_MONITOR_INTERVAL = 15            # seconds between network checks

BOOT_AP_GRACE = 60                      # if still offline after boot grace -> enter AP mode
BOOT_AP_CUTOFF = 15 * 60                # ONLY allow *automatic* entry into AP mode within this many seconds of boot
AP_MAX_DURATION = 15 * 60               # AP mode lifetime (fixed, not extended by web activity)
AP_POST_CLOSE_REBOOT_AFTER = 24 * 60 * 60  # if still offline 24h after closing AP -> reboot

GW_DOWN_RECONNECT_AFTER = 5 * 60        # gateway unreachable for this long -> start reconnect attempts
GW_DOWN_REBOOT_AFTER = 30 * 60          # gateway unreachable for this long -> reboot
RECONNECT_ATTEMPT_INTERVAL = 2 * 60     # interval between reconnect attempts

# After applying WiFi config, this appliance only requires *local* IPv4
# connectivity (it does not require Internet access):
#   - NetworkManager reports wlan0 connected/activated
#   - wlan0 has a non-link-local RFC1918 IPv4 address (i.e., not 169.254/16)
WAIT_FOR_CONNECTION_TIMEOUT = 45        # Seconds to wait for local IPv4 after config
WAIT_FOR_CONNECTION_INTERVAL = 2        # Poll interval for local IPv4 checks


def _setup_logging() -> None:
    """
    Configure logging to stdout and (if possible) to a log file.
    The service must keep running even if the log file cannot be created.
    """
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    # Avoid duplicate handlers if called more than once
    if logger.handlers:
        return

    formatter = logging.Formatter(
        "%(asctime)s [%(levelname)s] %(message)s"
    )

    # Always log to stdout
    stream_handler = logging.StreamHandler(sys.stdout)
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    # Try to add file logging
    try:
        log_dir = os.path.dirname(LOG_FILE) or "."
        os.makedirs(log_dir, exist_ok=True)

        file_handler = logging.FileHandler(LOG_FILE)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

    except Exception as e:
        logger.error(
            "Failed to initialise file logging (%s); continuing with stdout only.",
            e,
        )


# Set up logging
def _setup_logging() -> None:
    """
    Configure logging to a file if possible; fall back to stdout if the log path
    is missing/unwritable. This script is intended to run continuously, so it
    must not fail just because /var/log isn't ready yet.
    """
    try:
        log_dir = os.path.dirname(LOG_FILE) or "."
        os.makedirs(log_dir, exist_ok=True)
        logging.basicConfig(
            filename=LOG_FILE,
            level=logging.INFO,
            format="%(asctime)s [%(levelname)s] %(message)s",
        )
    except Exception as e:
        # Last-resort fallback: log to stdout so the service still runs.
        logging.basicConfig(
            stream=sys.stdout,
            level=logging.INFO,
            format="%(asctime)s [%(levelname)s] %(message)s",
        )
        logging.error("Failed to initialise file logging (%s); using stdout instead.", e)

_setup_logging()

@dataclass
class NetworkMonitorState:
    # Link state (reported via /status and UI)
    wifistate: str = "unknown"        # "configured" / "unconfigured" / "unknown"
    wiredstate: str = "unknown"       # "connected" / "disconnected" / "unknown"
    connectivity_ok: bool = False     # "healthy" using the same validation logic as initial wifi checks

    # Setup / AP state
    setup_mode: bool = False
    force_setup_mode: bool = False
    manual_ap_active: bool = False

    # Timers (monotonic seconds)
    boot_time: Optional[float] = None
    ap_enter_time: Optional[float] = None
    ap_closed_time: Optional[float] = None
    ap_exhausted: bool = False

    # Degradation tracking for "healthy connectivity"
    conn_down_start: Optional[float] = None
    last_reconnect_attempt: Optional[float] = None

    # ---- WiFi apply workflow / wait-page status ----
    apply_in_progress: bool = False
    # idle | applying | ok | failed
    last_apply_result: str = "idle"
    # short error code/message (e.g. nmcli-failed, no-local-ip)
    last_apply_error: str = ""

    # ---- Manual AP-mode request (from WebUI via localhost) ----
    ap_request_reason: str = ""


STATE = NetworkMonitorState()

# Synchronisation primitive for shared state
state_lock = threading.Lock()

# Serialise AP start/stop transitions
ap_mode_lock = threading.Lock()

# Manual AP-mode request (from the normal WebUI via localhost)
ap_request_event = threading.Event()

# AP / host configuration
AP_IFNAME = "wlan0"
AP_CONNECTION_NAME = "Hotspot"  # default/fixed name for our AP connection
HOSTNAME = get_system_hostname()
# NOTE: HOSTNAME can change at runtime; prefer get_system_hostname() when constructing
# user-facing URLs. Keep this for legacy/logging only.
HOST_SETUP_URL = f"http://{HOSTNAME}.local/setup"

app = Flask(__name__)

# ** LOGGING **

_last_log_msg: str | None = None
_last_log_time: float = 0.0
_last_logged_values: dict[str, object] = {}

def log(msg: str) -> None:
    """Helper to log messages, suppressing identical repeats."""
    global _last_log_msg, _last_log_time
    now = time.monotonic()

    # suppress identical messages if they occur back-to-back within 60s
    if msg == _last_log_msg and (now - _last_log_time) < 60:
        return

    _last_log_msg = msg
    _last_log_time = now
    logging.info(msg)


def log_on_change(key: str, value: object, msg: str) -> None:
    """Log msg only when (key -> value) changes."""
    prev = _last_logged_values.get(key, object())
    if prev != value:
        _last_logged_values[key] = value
        log(msg)


# ** SETUP/AP MODE **

def clear_apmode_flag() -> None:
    try:
        if os.path.exists(AP_MODE_FLAG_PATH):
            log(f"Removing stale AP flag at startup: {AP_MODE_FLAG_PATH}")
            os.remove(AP_MODE_FLAG_PATH)
    except Exception:
        log(f"Failed to remove %s at startup {AP_MODE_FLAG_PATH}")


def update_apmode_flag(in_setup: bool) -> None:
    """Create or remove the AP mode flag file at AP_MODE_FLAG_PATH."""
    try:
        if in_setup:
            if not os.path.exists(AP_MODE_FLAG_PATH):
                with open(AP_MODE_FLAG_PATH, "w", encoding="utf-8") as f:
                    f.write("1\n")
                log(f"Created AP mode flag file at {AP_MODE_FLAG_PATH}")
        else:
            if os.path.exists(AP_MODE_FLAG_PATH):
                os.remove(AP_MODE_FLAG_PATH)
                log(f"Removed AP mode flag file at {AP_MODE_FLAG_PATH}")
    except Exception as e:
        log(f"Error updating AP mode flag file {AP_MODE_FLAG_PATH}: {e}")


def enter_setup_mode(reason: str = "") -> None:
    """Transition into SetupMode and start AP mode, if permitted.

    AP mode is only allowed once per boot cycle. Once AP_MAX_DURATION elapses and
    AP mode is closed, it will not be re-entered until the device is power-cycled.
    """
    with state_lock:
        if STATE.setup_mode:
            return
        if STATE.ap_exhausted and not STATE.force_setup_mode:
            # Don't automatically re-enter AP mode after the 15-minute window.
            return
        STATE.setup_mode = True
        STATE.ap_enter_time = time.monotonic()

    log(f"Entering SetupMode. Reason: {reason}")
    start_ap_mode()
    update_apmode_flag(True)

def leave_setup_mode(reason: str = "") -> None:
    """Transition out of SetupMode and stop AP mode, if currently active."""
    with state_lock:
        if not STATE.setup_mode:
            return
        STATE.setup_mode = False
        STATE.ap_enter_time = None
        STATE.ap_closed_time = time.monotonic()
        STATE.force_setup_mode = False
        STATE.manual_ap_active = False

    log(f"Leaving SetupMode. Reason: {reason}")
    update_apmode_flag(False)
    stop_ap_mode()

def get_configured_wifi_connection_name() -> Optional[str]:
    """Return the configured *client* WiFi connection name, if any.

    The configuration UI stores the intended NetworkManager connection name in
    CONFIGURED_SSID. If that file is missing or empty, we treat WiFi as
    unconfigured.
    """
    try:
        if not os.path.isfile(CONFIGURED_SSID):
            return None
        with open(CONFIGURED_SSID, "r", encoding="utf-8") as f:
            name = f.read().strip()
        return name or None
    except Exception as e:
        log(f"Error reading {CONFIGURED_SSID}: {e}")
        return None


def is_wifi_configured() -> bool:
    """True if a WiFi client connection has been configured."""
    return get_configured_wifi_connection_name() is not None


def is_wifi_connected() -> bool:
    """True if wlan0 is connected to a non-AP WiFi network."""
    result = run_cmd(["nmcli", "-t", "-f", "DEVICE,TYPE,STATE,CONNECTION", "device", "status"])
    if result.returncode != 0:
        log(f"Error while checking WiFi connection state: {result.stderr.strip()}")
        return False

    for line in result.stdout.splitlines():
        if not line:
            continue
        parts = line.split(":", 3)
        if len(parts) != 4:
            continue
        device, dev_type, state, conn = parts
        if device != AP_IFNAME:
            continue
        if dev_type != "wifi":
            continue
        if state not in ("connected", "activated") or not conn:
            return False

        # Ensure we are not in AP mode
        mode_result = run_cmd(["nmcli", "-t", "-f", "802-11-wireless.mode", "connection", "show", conn])
        if mode_result.returncode != 0:
            log(f"Error checking mode for connection '{conn}': {mode_result.stderr.strip()}")
            return False

        mode_line = mode_result.stdout.strip()
        _, _, mode = mode_line.partition(":")
        mode = mode.strip().lower()

        return mode != "ap"

    return False

def is_wifi_client_healthy(
    ifname: str = AP_IFNAME,
    wifi_connected: Optional[bool] = None,
) -> bool:
    """
    WiFi "health" using the same logic as initial validation:
    - must be connected to a non-AP WiFi profile (is_wifi_connected)
    - must have a non-link-local RFC1918 IPv4 address (is_local_ipv4_ready)
    - must have a reachable default gateway (is_gateway_reachable)
    """
    if wifi_connected is None:
        wifi_connected = is_wifi_connected()

    if not wifi_connected:
        return False
    if not is_local_ipv4_ready(ifname):
        return False
    return is_gateway_reachable()


import glob

def is_wired_connected() -> bool:
    """Return True if any wired (ethernet) interface has carrier."""
    # Traditional + predictable ethernet names
    patterns = (
        "/sys/class/net/eth*/carrier",
        "/sys/class/net/en*/carrier",
    )

    for pat in patterns:
        for path in glob.glob(pat):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    if f.read().strip() == "1":
                        return True
            except OSError:
                # Interface disappeared or permissions issue; ignore
                continue

    return False

import ipaddress

_OK_NEIGH_STATES = {"REACHABLE", "STALE", "DELAY", "PROBE", "PERMANENT"}

def _run_ip_json(args: list[str]) -> list[dict]:
    p = run_cmd(["ip", "-j", *args], timeout=2.0)
    if p.returncode != 0:
        raise RuntimeError(
            f"`ip -j {' '.join(args)}` failed: rc={p.returncode}, stderr={p.stderr.strip()}"
        )
    out = p.stdout.strip()
    return json.loads(out) if out else []

def _stateset(state_field) -> set[str]:
    # ip -j may return "state": "STALE" or "state": ["STALE"]
    if isinstance(state_field, list):
        return {str(s).upper() for s in state_field}
    if isinstance(state_field, str):
        return {state_field.upper()}
    return set()

def is_gateway_reachable() -> bool:
    """
    Kernel-based gateway reachability:
    - Read default gateway IP (and default dev if available)
    - Read all neighbor entries for that gateway (across all devs)
    - Prefer an OK-state entry on the default dev, else any OK-state entry.
    - Primes gateway (icmp echo) prior to testing if possible
    """
    try:
        routes = _run_ip_json(["route", "show", "default"])
        if not routes:
            return False

        r0 = routes[0]
        gw = r0.get("gateway")
        default_dev = r0.get("dev")  # may be None

        if not gw:
            return False

        try:
            ipaddress.ip_address(gw)
        except ValueError:
            return False

        # Prime neighbor state before inspecting ip neigh if possibile
        # This does not define reachability; it just causes the kernel to resolve/refresh.
        if default_dev:
            prime_gateway(gw)

        neigh = _run_ip_json(["neigh", "show", "to", gw])  # NOTE: no dev filter
        if not neigh:
            return False

        # 1) Prefer an OK-state neighbor on the default route's interface
        if default_dev:
            for n in neigh:
                if n.get("dev") == default_dev and (_stateset(n.get("state")) & _OK_NEIGH_STATES):
                    return True

        # 2) Otherwise accept any OK-state neighbor entry
        for n in neigh:
            if _stateset(n.get("state")) & _OK_NEIGH_STATES:
                return True

        return False

    except Exception as e:
        log(f"Kernel gateway reachability check failed: {e}")
        return False


_RFC1918_NETS = (
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
)
_LINK_LOCAL_NET = ipaddress.ip_network("169.254.0.0/16")

def _is_rfc1918_ipv4(ip: ipaddress.IPv4Address) -> bool:
    return any(ip in n for n in _RFC1918_NETS)

def _nmcli_dev_show_fields(ifname: str, fields: list[str]) -> dict[str, list[str]]:
    """Return selected `nmcli -t ... dev show <ifname>` fields.

    Returns a dict mapping field-name to list of values (nmcli can emit multiple
    keys like IP4.ADDRESS[1], IP4.ADDRESS[2], ...).
    """
    r = run_cmd(["nmcli", "-t", "-f", ",".join(fields), "device", "show", ifname])
    if r.returncode != 0:
        return {}
    out: dict[str, list[str]] = {}
    for line in r.stdout.splitlines():
        if ":" not in line:
            continue
        k, v = line.split(":", 1)
        k = k.strip()
        v = v.strip()
        if not k:
            continue
        base = k.split("[", 1)[0]  # normalise e.g. IP4.ADDRESS[1] -> IP4.ADDRESS
        out.setdefault(base, []).append(v)
    return out

def is_local_ipv4_ready(ifname: str = AP_IFNAME) -> bool:
    """Local-only connectivity check.

    True when NetworkManager reports the device connected/activated AND the
    interface has a non-link-local RFC1918 IPv4 address.
    """
    try:
        info = _nmcli_dev_show_fields(ifname, ["GENERAL.STATE", "IP4.ADDRESS"])
        if not info:
            return False

        # GENERAL.STATE is like: "100 (connected)" or "30 (disconnected)"
        state_vals = info.get("GENERAL.STATE", [])
        if not state_vals:
            return False
        state_str = state_vals[0]
        try:
            state_code = int(state_str.split()[0])
        except Exception:
            state_code = -1
        if state_code != 100:
            return False

        addrs = info.get("IP4.ADDRESS", [])
        if not addrs:
            return False

        for a in addrs:
            # nmcli returns "192.168.1.42/24"
            try:
                ip = ipaddress.ip_interface(a).ip
            except Exception:
                continue
            if not isinstance(ip, ipaddress.IPv4Address):
                continue
            if ip in _LINK_LOCAL_NET:
                continue
            if _is_rfc1918_ipv4(ip):
                return True

        return False
    except Exception as e:
        log(f"Local IPv4 readiness check failed: {e}")
        return False


def get_ap_ssid(ifname: str) -> str:
    """Generate an SSID for the AP based on the interface MAC address.

    Format: autostream_XXXX where XXXX are the last four hex digits of the MAC.
    """
    result = run_cmd(["cat", f"/sys/class/net/{ifname}/address"])
    if result.returncode != 0:
        log(
            f"Error reading MAC address for {ifname}: {result.stderr.strip()}; using default SSID"
        )
        return "autostream_SETUP"

    mac = result.stdout.strip().replace(":", "")
    suffix = mac[-4:].upper() if len(mac) >= 4 else "0000"
    ssid = f"autostream_{suffix}"
    log(f"Using AP SSID '{ssid}' for interface {ifname}")
    return ssid


# ** WIFI CONFIGURATION **

def _get_active_wifi_connection_name(ifname: str = "wlan0") -> str:
    """
    Return the active connection profile name for a wifi device, or "" if unknown.
    Uses device status, so it works even if profiles are named 'netplan-wlan0-<SSID>'.
    """
    r = run_cmd(["nmcli", "-t", "-f", "DEVICE,TYPE,STATE,CONNECTION", "device", "status"])
    if r.returncode != 0:
        return ""
    for line in r.stdout.splitlines():
        parts = line.split(":")
        if len(parts) != 4:
            continue
        dev, dev_type, state, conn = parts
        if dev == ifname and dev_type == "wifi" and state in ("connected", "activated") and conn:
            return conn
    return ""

def _get_active_wifi_ssid(ifname: str = "wlan0") -> str:
    """
    Return the SSID currently in use on the given wifi interface, or "" if unknown.
    Uses `nmcli device wifi list ifname <ifname>` and looks for the in-use marker.
    """
    r = run_cmd(["nmcli", "-t", "-f", "IN-USE,SSID", "device", "wifi", "list", "ifname", ifname])
    if r.returncode != 0:
        return ""
    for line in r.stdout.splitlines():
        # Format: "*:MySSID" or ":OtherSSID"
        parts = line.split(":", 1)
        if len(parts) != 2:
            continue
        in_use, ssid = parts
        if in_use.strip() == "*" and ssid:
            return ssid
    return ""

def configure_wifi_with_nmcli(ssid: str, password: str) -> bool:
    """Configure WiFi using nmcli for the given SSID and password.

    Returns True on apparent success, False otherwise.
    """
    # Remove any existing connection for this network
    run_cmd(["nmcli", "connection", "delete", ssid])
    # Rescan...
    result = run_cmd(["nmcli", "dev", "wifi", "rescan"])
    if result.returncode == 0:
        log("nmcli rescan successful.")
    else:
        log("nmcli rescan failed. Unable to connect to WiFi at this time.")
        return False
    # Then attempt connection...
    cmd = [
        "nmcli",
        "device",
        "wifi",
        "connect",
        ssid,
    ]

    # Build a sanitised version for logging to avoid writing WiFi password into log
    log_cmd = cmd.copy()

    if password:
        cmd.extend(["password", password])
        log_cmd.extend(["password", "*" * len(password)])
    else:
        log("WiFi configuration requested with empty password (open network)")

    log(f"Running WiFi connect command: {' '.join(log_cmd)}")

    # Note: passing in log_cmd so run_cmd() warnings don't leak cleartext password
    result = run_cmd(cmd, log_cmd=log_cmd)

    if result.returncode == 0:
        log("nmcli reported successful WiFi configuration")
        # Store only if the device is truly connected; avoids saving on auth failure.
        conn_name = _get_active_wifi_connection_name(AP_IFNAME)
        if not conn_name:
            log("nmcli connect returned success but device is not connected; not saving config")
            return False
        try:
            with open(CONFIGURED_SSID, "w") as f:
                f.write(f"{conn_name}\n")
            log(f"WiFi connection name stored in {CONFIGURED_SSID}: '{conn_name}'")
        except Exception as e:
            log(f"Could not create or update {CONFIGURED_SSID}: {e}")
        return True
    else:
        # nmcli can report failure even if NetworkManager ultimately connects
        # (e.g., auto-activating an existing profile). Verify actual connectivity
        # before declaring failure / returning to SetupMode.
        log("nmcli failed to configure WiFi; see previous logs for details")

        # Fast-fail on obvious credential/auth problems to avoid ~10s delay.
        err = (result.stderr or "").lower()
        if "secrets were required" in err or "invalid secrets" in err or "wrong password" in err:
            return False
 
        if wait_for_connection(timeout=10, interval=1):
            active_ssid = _get_active_wifi_ssid(AP_IFNAME)
            conn_name = _get_active_wifi_connection_name(AP_IFNAME)
            if active_ssid == ssid and conn_name:
                log(
                    "WiFi appears connected despite nmcli rc!=0 "
                    f"(active SSID='{active_ssid}', connection='{conn_name}'); treating as success"
                )
                try:
                    with open(CONFIGURED_SSID, "w") as f:
                        f.write(f"{conn_name}\n")
                    log(f"WiFi connection name stored in {CONFIGURED_SSID}: '{conn_name}'")
                except Exception as e:
                    log(f"Could not create or update {CONFIGURED_SSID}: {e}")
                return True

        return False


def wait_for_connection(timeout: int = 20, interval: int = 2) -> bool:
    """Wait up to 'timeout' seconds for *local* IPv4 readiness.

    This appliance is designed to operate local-only, so after applying WiFi
    credentials we treat success as:
      - NetworkManager reports wlan0 connected/activated
      - wlan0 has a non-link-local RFC1918 IPv4 address

    (The ongoing health monitor can still use the gateway heuristic separately.)
    """
    deadline = time.monotonic() + timeout
    while time.monotonic() < deadline:
        if is_local_ipv4_ready(AP_IFNAME):
            return True
        time.sleep(interval)
    return False


def start_ap_mode() -> None:
    """Put the WiFi adapter into open AP (hotspot) mode using nmcli.

    The SSID is autostream_XXXX where XXXX are the last four hex digits of the
    adapter's MAC address. The hotspot is open (no password). The Flask app
    acts as the captive portal HTTP server; DNS/DHCP redirection is assumed to
    be handled elsewhere.
    """
    with ap_mode_lock:
        log("Enabling AP mode for SetupMode")

        ssid = get_ap_ssid(AP_IFNAME)

        # Try to bring down any existing hotspot connection first
        # run_cmd(["nmcli", "connection", "down", AP_CONNECTION_NAME])

        # Delete any existing connection with the same name
        # this also takes it down, if running)
        run_cmd(["nmcli", "connection", "delete", AP_CONNECTION_NAME])

        # Create the connection
        log(f"Creating AP connection '{AP_CONNECTION_NAME}' with SSID '{ssid}'")
        run_cmd([
            "nmcli", "connection", "add",
            "type", "wifi",
            "ifname", AP_IFNAME,
            "con-name", AP_CONNECTION_NAME,
            "autoconnect", "no",
            "ssid", ssid,
            "802-11-wireless.mode", "ap",
            "ipv4.method", "manual",
            "ipv4.addresses", "192.168.4.1/24",
            "ipv4.never-default", "yes",
            "ipv6.method", "ignore",
        ])

        # Bring up the AP connection
        run_cmd(["nmcli", "connection", "up", AP_CONNECTION_NAME])
        run_cmd(["systemctl", "start", "autostream_dnsmasq.service"])

        # Hostname may change at runtime; construct the portal URL dynamically.
        current_host = get_system_hostname()
        log(f"Setup portal expected at http://{current_host}.local/setup while in AP mode")


def stop_ap_mode() -> None:
    """Tear down AP mode.

    This is primarily used when leaving SetupMode via the monitor loop.
    """
    with ap_mode_lock:
        log("Disabling AP mode after leaving SetupMode")
        run_cmd(["systemctl", "stop", "autostream_dnsmasq.service"])
        run_cmd(["nmcli", "connection", "delete", AP_CONNECTION_NAME])
        with state_lock:
            STATE.ap_exhausted = True


def scan_wifi_networks(ifname: str = AP_IFNAME):
    """Scan for WiFi networks and return a list of dicts with ssid and signal.

    - Deduplicates SSIDs
    - Keeps the strongest signal per SSID
    - Returns networks ordered by signal strength (highest first)
    """
    cmd = [
        "nmcli",
        "-t",
        "-f",
        "SSID,SIGNAL",
        "device",
        "wifi",
        "list",
        "ifname",
        ifname,
    ]

    result = run_cmd(cmd)
    if result.returncode != 0:
        log(f"Error scanning WiFi networks: {result.stderr.strip()}")
        return []

    strongest_by_ssid: dict[str, int] = {}

    for line in result.stdout.splitlines():
        if not line:
            continue

        # nmcli -t uses ':' as field separator
        ssid, _, signal = line.partition(":")
        ssid = ssid.strip()

        if not ssid:
            continue

        try:
            signal_val = int(signal)
        except ValueError:
            continue

        # Keep only the strongest signal per SSID
        if signal_val > strongest_by_ssid.get(ssid, -1):
            strongest_by_ssid[ssid] = signal_val

    # Convert to list of dicts and sort by signal strength (descending)
    return sorted(
        (
            {"ssid": ssid, "signal": signal}
            for ssid, signal in strongest_by_ssid.items()
        ),
        key=lambda n: n["signal"],
        reverse=True,
    )


def apply_wifi_async(ssid: str, pw: str) -> None:
    try:
        with state_lock:
            STATE.last_apply_result = "applying"
            STATE.last_apply_error = ""
        log(f"Async apply starting for SSID '{ssid}'")

        time.sleep(0.5)
        leave_setup_mode("Applying WiFi configuration")

        success = configure_wifi_with_nmcli(ssid, pw)
        if success:
            connected = wait_for_connection(
                timeout=WAIT_FOR_CONNECTION_TIMEOUT,
                interval=WAIT_FOR_CONNECTION_INTERVAL,
            )
            if connected:
                with state_lock:
                    STATE.last_apply_result = "ok"
                    STATE.last_apply_error = ""
                log("WiFi configuration and connectivity verified; leaving SetupMode")
                with state_lock:
                    STATE.force_setup_mode = False
                leave_setup_mode("WiFi configuration successful and connectivity verified")
            else:
                with state_lock:
                    STATE.last_apply_result = "failed"
                    STATE.last_apply_error = "no-local-ip"
                log("Local IPv4 check failed after WiFi configuration; entering SetupMode")
                with state_lock:
                    STATE.force_setup_mode = True
                enter_setup_mode("Local IPv4 check failed after WiFi configuration")
        else:
            with state_lock:
                STATE.last_apply_result = "failed"
                STATE.last_apply_error = "nmcli-failed"
            log("WiFi configuration failed; returning to SetupMode")
            with state_lock:
                STATE.force_setup_mode = True
            enter_setup_mode("nmcli failed to configure WiFi")
    finally:
        with state_lock:
            STATE.apply_in_progress = False

# ** WEB APP **

@app.before_request
def touch_ap_timer():
    """No-op placeholder.

    AP mode lifetime is fixed (AP_MAX_DURATION) and is not extended by web activity.
    Kept to avoid changing the Flask routing behaviour elsewhere.
    """
    return

def render_setup_page(error_code: str = "") -> str:
    """Return the HTML for the WiFi setup page (styled like autostream_webui.py),
    while trying hard to avoid iOS credential-save prompts.
    Includes iOS-friendly focus handling (avoid auto-focus in key field).
    """

    # Map internal error codes to a user-friendly message
    msg = ""
    if error_code:
        if error_code == "no-local-ip":
            msg = (
                "WiFi connected but no usable local IPv4 address was obtained. "
                "Check DHCP is enabled on the network or try another."
            )
        elif error_code == "nmcli-failed":
            msg = "Unable to connect to that WiFi network. Check the key and try again."
        else:
            msg = "WiFi connection attempt failed. Please try again."

    alert_html = ""
    if msg:
        alert_html = f"""
        <div class="alert">
          <strong>Connection failed.</strong><br>
          {html.escape(msg)}
        </div>
        """

    return f"""<!DOCTYPE html>
        <html>
        <head>
        <meta charset="utf-8">
        <title>Network Setup</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
        <style>{STYLE_CSS}</style>
        <style>
          /* Mask text input like a password field without using type=password (iOS prompt heuristic) */
          .masked {{
            -webkit-text-security: disc; /* Safari/iOS */
            text-security: disc;         /* non-standard fallback */
          }}
          /* Put key field + eye button on one line */
          .row {{
            display: flex;
            align-items: stretch;
            gap: 0.5rem;
          }}
          .row .grow {{
            flex: 1 1 auto;
            min-width: 0; /* important: allows the input to shrink instead of overflowing */
          }}
          .row input,
          .row button {{
            margin-top: 0.25rem; /* match the existing input top margin from STYLE_CSS */
          }}
          .status {{
            font-size: 0.8rem;     /* smaller text */
            text-align: center;   /* center horizontally */
            color: #666;          /* optional: softer “status” look */
            margin-top: 0.5rem;   /* optional spacing from controls */
          }}
          #toggle-mask svg {{
            position: relative;
            top: 1px;        /* nudges the eye icon down a bit */
            display: block;  /* removes baseline alignment quirks */
          }}
        </style>
        <script>
            let _didInitialFocus = false;

            async function fetchStatus() {{
                try {{
                    const resp = await fetch('/status', {{ cache: 'no-store' }});
                    if (!resp.ok) return;
                    const data = await resp.json();
                    const el = document.getElementById('status');
                    if (!el) return;
                    el.textContent =
                        'WiFi: ' + data.wifistate + ', ' +
                        'Wired: ' + data.wiredstate + ', ' +
                        'Gateway reachable: ' + data.gateway_reachable + ', ' +
                        'SetupMode: ' + data.SetupMode;
                }} catch (e) {{}}
            }}

            function focusSsidSelectSoon() {{
            if (_didInitialFocus) return;

            const select = document.getElementById('ssid-select');
            const key = document.getElementById('key-field');
            if (!select) return;

            // If the user has already interacted, don't steal focus.
            const ae = document.activeElement;
            const userIsTyping = (ae && (ae === key || ae === select));

            if (!userIsTyping) {{
                setTimeout(() => {{
                try {{ select.focus(); }} catch (e) {{}}
                }}, 250); // iOS captive portal is happier with a slight delay
            }}

            _didInitialFocus = true;
            }}

            async function fetchNetworks() {{
            try {{
                const resp = await fetch('/networks', {{ cache: 'no-store' }});
                if (!resp.ok) return;
                const data = await resp.json();
                const select = document.getElementById('ssid-select');
                if (!select) return;

                const current = select.value;
                select.innerHTML = '';

                const ph = document.createElement('option');
                ph.value = '';
                ph.textContent = 'Select a WiFi network…';
                select.appendChild(ph);

                for (const n of data) {{
                const opt = document.createElement('option');
                opt.value = n.ssid || '';
                const sig = (typeof n.signal === 'number') ? (' (' + n.signal + '%)') : '';
                opt.textContent = (n.ssid || '(hidden)') + sig;
                select.appendChild(opt);
                }}

                if (current) select.value = current;

                // After first successful population, guide focus to the SSID dropdown (iOS).
                focusSsidSelectSoon();
            }} catch (e) {{}}
            }}

            function armKeyField() {{
            const key = document.getElementById('key-field');
            if (!key) return;

            // iOS often auto-focuses the first "fillable" input; readonly prevents that.
            // Allow editing as soon as the user interacts.
            const enable = () => key.removeAttribute('readonly');

            key.addEventListener('pointerdown', enable, {{ once: true }});
            key.addEventListener('focus', enable, {{ once: true }});

            // Also enable when user selects an SSID (common flow)
            const select = document.getElementById('ssid-select');
            if (select) {{
                select.addEventListener('change', () => {{
                enable();
                // Only nudge focus to key if they picked a real SSID
                if (select.value) setTimeout(() => {{ try {{ key.focus(); }} catch (e) {{}} }}, 100);
                }});
            }}
            }}

            function installHandlers() {{
                const form = document.getElementById('wifi-form');
                if (!form) return;

                // Optional: allow user to briefly reveal/mask the key
                const toggle = document.getElementById('toggle-mask');
                const key = document.getElementById('key-field');
                const eyeOpen = document.getElementById('eye-open');
                const eyeClosed = document.getElementById('eye-closed');

                const revealWrap = document.getElementById('key-reveal-wrap');
                const reveal = document.getElementById('key-reveal');

                form.addEventListener('submit', async (ev) => {{
                    ev.preventDefault();

                    const btn = document.getElementById('connect-btn');
                    const status = document.getElementById('status');
                    if (btn) btn.disabled = true;
                    if (status) status.textContent = 'Submitting WiFi settings…';

                    const ssid = document.getElementById('ssid-select')?.value || '';
                    const k = document.getElementById('key-field')?.value || '';

                    try {{
                    // Send the server the expected parameter names without exposing them in the DOM.
                    const body = new URLSearchParams();
                    body.set('ssid', ssid);
                    body.set('password', k);

                    const resp = await fetch('/setup', {{
                        method: 'POST',
                        headers: {{ 'Content-Type': 'application/x-www-form-urlencoded' }},
                        body: body.toString(),
                        cache: 'no-store',
                        credentials: 'same-origin',
                    }});

                    const html = await resp.text();
                    document.open();
                    document.write(html);
                    document.close();
                    }} catch (e) {{
                    if (status) status.textContent = 'Submit failed. Please try again.';
                    if (btn) btn.disabled = false;
                    }}
                }});

            if (toggle && key && revealWrap && reveal) {{
                const setIcons = (revealing) => {{
                    // revealing=true -> show "eye-closed" (tap to hide)
                    // revealing=false -> show "eye-open" (tap to show)
                    if (eyeOpen && eyeClosed) {{
                    eyeOpen.style.display = revealing ? 'none' : 'inline';
                    eyeClosed.style.display = revealing ? 'inline' : 'none';
                    }}
                    toggle.setAttribute(
                    'aria-label',
                    revealing ? 'Hide password' : 'Show password'
                    );
                }};

                const syncReveal = () => {{
                    // Mirror current input value into the reveal panel
                    reveal.textContent = key.value || '';
                }};

                // keep it synced while user types
                key.addEventListener('input', () => {{
                    if (revealWrap.style.display !== 'none') syncReveal();
                }});

                // also catch programmatic / blur changes
                key.addEventListener('change', () => {{
                    if (revealWrap.style.display !== 'none') syncReveal();
                }});

                // initial icon state (hidden)
                setIcons(false);

                toggle.addEventListener('click', () => {{
                    const currentlyVisible = (revealWrap.style.display !== 'none');
                    const nextVisible = !currentlyVisible;

                    if (nextVisible) {{
                    syncReveal();
                    revealWrap.style.display = 'block';
                    }} else {{
                    revealWrap.style.display = 'none';
                    }}

                    setIcons(nextVisible);
                }});
                }}
            }}

            window.addEventListener('load', () => {{
            // Ensure key field won't be auto-focused by iOS, and only becomes editable on interaction.
            armKeyField();

            fetchNetworks();
            fetchStatus();
            installHandlers();
            setInterval(fetchNetworks, 5000);
            setInterval(fetchStatus, 2000);

            // Extra nudge: if iOS still tries to focus something, move focus away from key.
            // (No-op on most browsers.)
            focusSsidSelectSoon();
            }});
        </script>
        </head>

        <body>
        <div class="container">
            <div class="banner">
            {BANNER_HTML}
            </div>

            <h1>Connect to WiFi</h1>

            {alert_html}

            <p>Select your WiFi network and enter the key (leave blank for open networks).</p>

            <!-- Use innocuous field names + non-password input to reduce iOS save-password heuristics -->
            <form id="wifi-form" method="post" action="/setup" autocomplete="off" novalidate>
            <label for="ssid-select">WiFi Network (SSID)</label>
            <select id="ssid-select" name="s" autocomplete="off">
                <option value="">Scanning…</option>
            </select>

            <label for="key-field">WiFi Passphrase/Password</label>
            <div class="row">
                <div class="grow">
                <input
                    id="key-field"
                    type="text"
                    name="k"
                    class="masked"
                    readonly
                    autocomplete="off"
                    autocapitalize="off"
                    autocorrect="off"
                    spellcheck="false"
                    inputmode="text"
                    placeholder="(leave blank for open networks)"
                />
                </div>
                <button id="toggle-mask"
                        class="pill-btn small"
                        type="button"
                        aria-label="Show password"
                        title="Show / hide">
                    <svg id="eye-open" xmlns="http://www.w3.org/2000/svg" width="18" height="18"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    <svg id="eye-closed" xmlns="http://www.w3.org/2000/svg" width="18" height="18"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        style="display:none;">
                        <path d="M17.94 17.94A10.94 10.94 0 0 1 12 20c-7 0-11-8-11-8
                                a21.82 21.82 0 0 1 5.06-6.94"/>
                        <path d="M1 1l22 22"/>
                        <path d="M9.53 9.53A3 3 0 0 0 12 15
                                a3 3 0 0 0 2.47-5.47"/>
                    </svg>
                </button>
            </div>
            <div id="key-reveal-wrap" class="key-reveal-wrap" style="display:none;">
                <pre id="key-reveal" class="key-reveal"></pre>
            </div>
            <br>
            <div class="hint">
                You may need to reconnect to your normal WiFi after pressing Connect.
            </div>
            <br>
            <button id="connect-btn" class="pill-btn" type="submit">Connect</button>
            </form>
            <br>
            <div class="status" id="status">Status: unknown</div>
        </div>
        </body>
        </html>
        """


def render_wait_page(selected_ssid: str = "") -> str:
    """Wait page shown immediately after submit."""
    ua = (request.headers.get("User-Agent") or "").lower()

    if "iphone" in ua or "ipad" in ua or "ipod" in ua:
        browser_name = "Safari"
    elif "android" in ua:
        browser_name = "Chrome"
    elif "windows" in ua:
        browser_name = "Browser"
    else:
        browser_name = "Browser"

    ssid_safe = html.escape(selected_ssid or "")
    # Hostname may change at runtime (e.g. user renames device); re-read when rendering.
    host_safe = html.escape(get_system_hostname())


    return f"""<!DOCTYPE html>
        <html>
        <head>
        <meta charset="utf-8">
        <title>Joining network…</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
        <style>{STYLE_CSS}</style>
        <script>
            async function poll() {{
            try {{
                const r = await fetch('/status', {{ cache: 'no-store' }});
                if (!r.ok) return;
                const s = await r.json();

                // Once apply is finished:
                if (!s.apply_in_progress) {{
                // If we're back in SetupMode, the join failed -> go back to setup
                if (s.SetupMode || s.last_apply_result === 'failed') {{
                    const e = encodeURIComponent(s.last_apply_error || 'failed');
                    window.location.replace('/setup?e=' + e + '&t=' + Date.now());
                    return;
                }}

                // If not in SetupMode, assume success path; send them to the mDNS host
                window.location.replace('http://{host_safe}.local/?t=' + Date.now());
                return;
                }}
            }} catch (e) {{}}
            }}

            setInterval(poll, 1200);
            window.addEventListener('load', poll);
        </script>

        </head>

        <body>
        <div class="container">
            {BANNER_HTML}

            <h1>Joining network…</h1>

            <p>Attempting to join the network <code>{ssid_safe}</code>.</p>

            <p>
            Open {browser_name} and go to <code>{host_safe}.local</code> to continue setup.
            </p>
        </div>
        </body>
        </html>
        """


@app.route("/", methods=["GET"])
def index():
    """Redirect root to the /setup page."""
    return redirect(url_for("setup"))

@app.errorhandler(404)
def page_not_found(_):
    return _captive_response(CAPTIVE_LANDING)


@app.route("/setup", methods=["GET", "POST"])
def setup():
    if request.method == "POST":
        # Accept both the “real” names and your innocuous names
        ssid = (request.form.get("ssid") or request.form.get("s") or "").strip()
        pw = request.form.get("password") or request.form.get("k") or ""

        if not ssid:
            log("WiFi configuration POST received without SSID")
            return _captive_response(render_setup_page())

        with state_lock:
            if STATE.apply_in_progress:
                log("Apply already in progress; showing wait page again")
                return _captive_response(render_wait_page(ssid))
                #return render_wait_page(ssid)
            STATE.apply_in_progress = True
            STATE.last_apply_result = "applying"
            STATE.last_apply_error = ""

        # IMPORTANT: return wait page first, then reconfigure in background
        t = threading.Thread(target=apply_wifi_async, args=(ssid, pw), daemon=True)
        t.start()
        return _captive_response(render_wait_page(ssid))

    # GET: show the setup form (include last failure, if any)
    with state_lock:
        e = (request.args.get("e") or "").strip()
        if not e and STATE.last_apply_result == "failed":
            e = STATE.last_apply_error or "failed"

    log(f"User requested /setup (error: {e})")

    return _captive_response(render_setup_page(e))


@app.route("/networks", methods=["GET"])
def networks():
    """Return a JSON list of available WiFi networks (SSID + signal)."""
    nets = scan_wifi_networks()
    return jsonify(nets)


@app.route("/status", methods=["GET"])
def status():
    """Return a simple JSON status including SetupMode and link states."""
    with state_lock:
        wifistate = STATE.wifistate
        wiredstate = STATE.wiredstate
        gateway_reachable = STATE.connectivity_ok
        SetupMode = STATE.setup_mode
        aip = STATE.apply_in_progress
        lar = STATE.last_apply_result
        lae = STATE.last_apply_error
    
    return jsonify(
        {
            "wifistate": wifistate,
            "wiredstate": wiredstate,
            "gateway_reachable": gateway_reachable,
            "SetupMode": SetupMode,
            "apply_in_progress": aip,
            "last_apply_result": lar,
            "last_apply_error": lae,
        }
    )


def _captive_response(html: str):
    resp = make_response(html, 200)
    resp.headers["Content-Type"] = "text/html; charset=utf-8"
    resp.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    resp.headers["Pragma"] = "no-cache"
    return resp

CAPTIVE_LANDING = """<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta http-equiv="refresh" content="0; url=/setup">
    <title>Wi-Fi setup</title>
  </head>
  <body>
    <p>Redirecting to setup…</p>
    <p><a href="/setup">Open setup</a></p>
  </body>
</html>
"""

# iOS / Apple captive probes
@app.route("/hotspot-detect.html", methods=["GET"])
@app.route("/library/test/success.html", methods=["GET"])
def apple_captive_probe():
    return _captive_response(CAPTIVE_LANDING)

# Android / Chrome probes
@app.route("/generate_204", methods=["GET"])
@app.route("/gen_204", methods=["GET"])
def android_probe():
    return _captive_response(CAPTIVE_LANDING)

# Windows NCSI probe
@app.route("/ncsi.txt", methods=["GET"])
@app.route("/connecttest.txt", methods=["GET"])
def windows_probe():
    return _captive_response(CAPTIVE_LANDING)


@app.route("/.well-known/captive-portal", methods=["GET"])
def captive_portal_api():
    """
    RFC 8910 Captive Portal API endpoint (DHCP option 114 points here).
    iOS/macOS expect application/captive+json and typically respect no-store.
    """
    # Use whatever host the client used (often 192.168.4.1 via DNS hijack / proxy)
    base = (request.host_url or "http://192.168.4.1/").rstrip("/")

    payload = {
        "captive": True,
        "user-portal-url": f"{base}/setup",
    }

    resp = make_response(json.dumps(payload), 200)
    resp.headers["Content-Type"] = "application/captive+json; charset=utf-8"
    resp.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
    resp.headers["Pragma"] = "no-cache"
    return resp


@app.route("/request_ap_mode", methods=["POST"])
def request_ap_mode():
    """Allow the normal (non-setup) WebUI to request AP/setup mode.

    This endpoint is intentionally only reachable from localhost.
    The network monitor loop will action the request asynchronously.
    """
    remote = request.remote_addr or ""
    if remote not in ("127.0.0.1", "127.0.1.1", "::1"):
        return jsonify({"ok": False, "error": "forbidden"}), 403

    reason = ""
    if request.is_json:
        payload = request.get_json(silent=True) or {}
        reason = str(payload.get("reason", "")).strip()
    if not reason:
        reason = (request.form.get("reason") or "").strip()

    with state_lock:
        STATE.ap_request_reason = reason
        ap_request_event.set()

    return jsonify({"ok": True, "queued": True})



# ** MAIN NETWORK STATUS MONITORING LOOP **


def network_monitor_loop():
    """Background loop to check network state and enforce the narrative rules.

    Summary of behaviour (ethernet always wins):
      - If wired ethernet is up: never enter AP mode; if currently in AP mode, exit it.
      - If WiFi is unconfigured OR still disconnected after BOOT_AP_GRACE seconds:
            enter AP mode (once per boot) for up to AP_MAX_DURATION seconds.
      - When AP mode closes after AP_MAX_DURATION:
            if WiFi is configured (and ethernet is still down) periodically try to connect.
            If still offline after AP_POST_CLOSE_REBOOT_AFTER, reboot.
      - If WiFi is configured and ethernet is down:
            use the kernel's view of the default gateway as a health check.
            If unreachable for > GW_DOWN_RECONNECT_AFTER: periodically attempt reconnect.
            If unreachable for > GW_DOWN_REBOOT_AFTER: reboot.
    """
    log("Starting network monitor loop")

    # Record boot time on first entry
    with state_lock:
        if STATE.boot_time is None:
            STATE.boot_time = time.monotonic()

    while True:
        now = time.monotonic()
        with state_lock:
            STATE.manual_ap_active = False

        with state_lock:
            boot_time = STATE.boot_time or now

        # Handle manual request to enter AP mode (from the normal WebUI via localhost).
        # This overrides the boot-time auto-AP cutoff.
        if ap_request_event.is_set():
            with state_lock:
                reason = STATE.ap_request_reason
                # Clear stored reason once consumed (optional but keeps it tidy)
                STATE.ap_request_reason = ""
                ap_request_event.clear()
                already_in_ap = STATE.setup_mode
            # If we're not already in AP mode, enter it now.
            if not already_in_ap:
                with state_lock:
                    STATE.manual_ap_active = True
                enter_setup_mode(reason=f"manual_request: {reason or 'UserRequest'}")
                time.sleep(NETWORK_MONITOR_INTERVAL)
                continue
            else:
                with state_lock:
                    STATE.manual_ap_active = True

        wifi_cfg = is_wifi_configured()
        wired_connected = is_wired_connected()
        wifi_connected = is_wifi_connected() if wifi_cfg else False

        # Requested health check change: reuse the same validation logic as initial wifi checks
        # Connectivity determination:
        # - Ethernet up => healthy
        # - Else WiFi must be (a) nmcli connected/activated to non-AP, (b) have RFC1918 IPv4,
        #   and (c) have reachable default gateway (kernel neighbor view)
        client_ok = (
            is_wifi_client_healthy(AP_IFNAME, wifi_connected=wifi_connected)
            if wifi_cfg
            else False
        )
        conn_ok = bool(wired_connected or client_ok)

        with state_lock:
            STATE.wifistate = "configured" if wifi_cfg else "unconfigured"
            STATE.wiredstate = "connected" if wired_connected else "disconnected"
            STATE.connectivity_ok = conn_ok
            log_on_change("wifistate", STATE.wifistate, f"WiFi state changed -> {STATE.wifistate}")
            log_on_change("wiredstate", STATE.wiredstate, f"Wired state changed -> {STATE.wiredstate}")
            log_on_change("gateway_reachable", STATE.connectivity_ok, f"Connectivity changed -> {STATE.connectivity_ok}")

        # Ethernet suppresses AP mode entirely.
        with state_lock:
            if wired_connected and not STATE.manual_ap_active:
                STATE.conn_down_start = None
                STATE.last_reconnect_attempt = None
                in_setup = STATE.setup_mode
                if in_setup:
                    leave_setup_mode("Wired ethernet is up; suppressing AP mode")
                time.sleep(NETWORK_MONITOR_INTERVAL)
                continue

        with state_lock:
            if wired_connected and STATE.manual_ap_active:
                # User explicitly requested AP mode; do not auto-suppress it just because
                # ethernet happens to be connected.
                STATE.conn_down_start = None
                STATE.last_reconnect_attempt = None

        # If we're currently in AP mode, enforce the fixed 15-minute lifetime.
        with state_lock:
            in_setup = STATE.setup_mode
            ap_started = STATE.ap_enter_time

        if in_setup and ap_started is not None:
            ap_age = now - ap_started
            if ap_age >= AP_MAX_DURATION:
                # Close AP mode; do not allow re-entry this boot (unless forced).
                with state_lock:
                    STATE.ap_exhausted = True
                    STATE.ap_closed_time = now
                    STATE.manual_ap_active = False
                leave_setup_mode(f"AP mode lifetime expired after {ap_age:.0f}s")
            time.sleep(NETWORK_MONITOR_INTERVAL)
            continue

        # Decide whether we should enter AP mode during the boot window.
        # Note: AP mode is only allowed once per boot (ap_exhausted).
        with state_lock:
            ap_exhausted = STATE.ap_exhausted
            forced = STATE.force_setup_mode

        if (not in_setup) and (not ap_exhausted) and (not forced):
            boot_age = now - boot_time
            # Auto-setup mode is only entered if:
            #   - WiFi is not configured OR WiFi is not connected
            #   - still offline AFTER the boot grace period.
            #   - still offline BEFORE the boot cutoff period.
            # This avoids immediately switching to AP mode before NetworkManager /
            # firmware has had a chance to come up.
            should_enter_ap = (
                boot_age >= BOOT_AP_GRACE
                and boot_age <= BOOT_AP_CUTOFF
                and ((not wifi_cfg) or (not wifi_connected))
            )

            if should_enter_ap:
                enter_setup_mode(
                    reason=f"boot_age={boot_age:.0f}s, wifi_cfg={wifi_cfg}, wifi_connected={wifi_connected}"
                )
                time.sleep(NETWORK_MONITOR_INTERVAL)
                continue

        # If AP mode has closed and we're still offline, periodically try to connect,
        # and reboot after AP_POST_CLOSE_REBOOT_AFTER.
        with state_lock:
            ap_exhausted = STATE.ap_exhausted
            ap_closed_time = STATE.ap_closed_time
            last_attempt = STATE.last_reconnect_attempt

        if ap_exhausted and wifi_cfg and (not wifi_connected):
            # Ensure we have a close time
            if ap_closed_time is None:
                with state_lock:
                    if STATE.ap_closed_time is None:
                        STATE.ap_closed_time = now
                    ap_closed_time = STATE.ap_closed_time

            offline_for = now - (ap_closed_time or now)

            # Periodic reconnect attempts.
            if (last_attempt is None) or (now - last_attempt >= RECONNECT_ATTEMPT_INTERVAL):
                with state_lock:
                    STATE.last_reconnect_attempt = now
                log(f"Post-AP reconnect attempt (offline_for={offline_for:.0f}s)")
                connect_to_configured_wifi()

            if offline_for >= AP_POST_CLOSE_REBOOT_AFTER:
                log(
                    f"Still offline {offline_for:.0f}s after AP mode closed "
                    f"(threshold {AP_POST_CLOSE_REBOOT_AFTER}s); rebooting"
                )
                reboot_system("NetworkDown")

            time.sleep(NETWORK_MONITOR_INTERVAL)
            continue

        # Connection reliability monitoring: WiFi configured, ethernet down.
        # Use the same "local IPv4 readiness" health indicator (conn_ok) as used elsewhere.
        if wifi_cfg:
            with state_lock:
                down_start = STATE.conn_down_start
                last_attempt = STATE.last_reconnect_attempt

            if not conn_ok:
                if down_start is None:
                    with state_lock:
                        STATE.conn_down_start = now
                    down_start = now

                down_for = now - down_start

                if down_for >= GW_DOWN_REBOOT_AFTER:
                    log(
                        f"Connectivity unhealthy for {down_for:.0f}s "
                        f"(threshold {GW_DOWN_REBOOT_AFTER}s); rebooting"
                    )
                    reboot_system("NetworkDown")

                if down_for >= GW_DOWN_RECONNECT_AFTER:
                    if (last_attempt is None) or (now - last_attempt >= RECONNECT_ATTEMPT_INTERVAL):
                        with state_lock:
                            STATE.last_reconnect_attempt = now
                        log(
                            f"Connectivity unhealthy for {down_for:.0f}s; "
                            "attempting reconnect"
                        )
                        connect_to_configured_wifi()
            else:
                with state_lock:
                    STATE.conn_down_start = None
                    STATE.last_reconnect_attempt = None

        time.sleep(NETWORK_MONITOR_INTERVAL)

def connect_to_configured_wifi() -> bool:
    """Attempt to bring up the configured WiFi client connection (if any).

    Returns True if nmcli was invoked (best-effort), False if there is no configured
    connection to try.
    """
    connection_name = get_configured_wifi_connection_name()
    if not connection_name:
        return False

    # Step 1 (requested): try device disconnect/reconnect first
    log(f"Attempting WiFi device bounce on {AP_IFNAME} (disconnect/reconnect) before bringing up '{connection_name}'")
    run_cmd(["nmcli", "device", "disconnect", AP_IFNAME])
    run_cmd(["nmcli", "device", "connect", AP_IFNAME])

    # Step 2: bring up the configured connection profile as a fallback/assist
    log(f"Attempting to connect to configured WiFi connection '{connection_name}'")
    run_cmd(["nmcli", "connection", "up", connection_name])
    return True



if __name__ == "__main__":
    log(f"**************************************************************************")
    log(f"autostream wifi monitor starting. Copyright (c) 2025, Lo-tech Systems Ltd.")

    # Check CPU
    check_cpu()

    # First, remove any lingering Hotspot connections configured that would otherwise
    # force the Pi to setup mode even though the WiFi is probably OK, and connect to
    # whatever network is configured (if it is configured).
    run_cmd(["nmcli", "connection", "delete", AP_CONNECTION_NAME])
    # an any associated hotspot request markers
    clear_apmode_flag()
    connect_to_configured_wifi()

    # Start the network monitor in a background thread
    monitor_thread = threading.Thread(target=network_monitor_loop, daemon=True)
    monitor_thread.start()

    # Ensure AP mode flag matches initial state
    update_apmode_flag(False)

    # Start the Flask app (HTTP server) on port 9080
    app.run(host="127.0.0.1", port=9080)
